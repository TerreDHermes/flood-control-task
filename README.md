# Тестовое задание для стажера на позицию «Golang-разработчик»
Реализовать интерфейс с методом для проверки правил флуд-контроля. Если за последние N секунд вызовов метода Check будет больше K, значит, проверка на флуд-контроль не пройдена.

-> Интерфейс FloodControl располагается в файле main.go.

-> Флуд-контроль может быть запущен на нескольких экземплярах приложения одновременно, поэтому нужно предусмотреть общее хранилище данных. Допустимо использовать любое на ваше усмотрение.

-> Поддержка конфигураций.

# Ход мыслей
Первая мысль - где хранить информацию о запросах? Кажется, что реляционная база данных слишком для этого тяжела и неудобна (из пушки по воробьям). Но 
в вакансии был один из пунктов - "Необходимо иметь опыт работы с реляционными базами данных (PostgreSQL, MySQL)". Поэтому решил взять PostgreSQL и попытаться как-то максимально оптимизировать работу.

Мы имеем временное окно (N), во время которого считаем количество запросов. Поэтому, нужно как-то удалять данные, если они устарели. Чем больше данных, тем дольше мы будем отбирать нужные данные, которые укладываются во временное окно. 

Варианты для удаления:
1) Во время вставки будет срабатывать тригер;
   
2) Написать отдельное приложение, которое будет обрабатывать базу данных (чистить старые данные);
   
3) Создать горутину, которая будет удалять данные каждые N секунд. В принципе, это и есть 2 пункт, просто все в одном.
 
4) Расширение для Postgres pg_cron. Можно выполнять любые действия над таблицей по расписанию.

Минус первого пункта - после каждой вставки происходит выборка,проверка,удаление... и то, если вообще за это время что-то устарело, возможно и нет. Слишком большая нагрузка на базу данных.

Минус 1, 2 и 3 пункта - нет общего консенсуса по времени жизни информации о запросе. Нужно придумывать методы взаиомедействия, чтобы придти к согласию.

Расширение pg_cron позволяет установить общие для всех правила. И выборка,проверка,удаление происходят раз M секунд. Нет постоянной нагрузки на базу данных. 

С данным расширением ни разу не сталкивался. Поэтому пришлось покопаться с документацией. Особые трудности возникли при сборке postres с pg_cron в Docker-контейнере.

# Запуск
Запуск Makefile из корневой папки:

```bash
make
```

Если будет Ping-ошибка, значит база данных не успела полностью запуститься. Подождем пару секунд и введём команду для запуска main.go

```bash
go run cmd/main.go
```

# Возможности в конфигурации
### Контейнер с PostreSQL
Возможна конфигурация параметров, которые используются при создании контейнера, в котором располагается наша база данных Postgres. Базовая конфигурация в Makefile:

<div align="center">
  <img src="https://github.com/TerreDHermes/TerreDHermes/blob/main/assets/vk/makefile.png" alt="Описание изображения" style="width: 100%;">
</div>

### Приложение (config.yml)
Возможна конфигурация параметров, которые использует приложение при подключении к базе данных Postgres. Базовая конфигурация в config.yml:

<div align="center">
  <img src="https://github.com/TerreDHermes/TerreDHermes/blob/main/assets/vk/config.yml.png" alt="Описание изображения" style="width: 100%;">
</div>

В config.yml можно настроить параметры N и K, N - время в секундах, K - количество вызовов метода Check

Добавлено расширение pg_cron в Postgres, которое позволяет выполнять функцию по обработке данных в таблице согласно расписанию. Если честно, на правильное подключение этого плагина ушло очень много времени.

<div align="center">
  <img src="https://github.com/TerreDHermes/TerreDHermes/blob/main/assets/vk/sql_up.png" alt="Описание изображения" style="width: 100%;">
</div>

Базовая конфигурация - каждые 25 секунд запускается функция, которая удаляет из таблицы данные, которые старше 20 секунд. То есть 20 секунд - время жизни кортежа в таблице. При условии, что показатель N < 20, зачем нам хранить данные, которые живут больше 20 секунд. Этот параметр (время жизни кортежа) можно менять в зависимости от N (если N=30, тогда время жизни кортежа меняем ,например, на 40).

При условии, когда много отдельных программ используют нашу базу, выставляется время жизни кортежа  равное большему N из всех N каждого участника. Участник - выявитель флуда со своими параметрами под свои задачи.

### Обновление расписания удаления (тоже config.yml, последние 2 строчки)
<div align="center">
  <img src="https://github.com/TerreDHermes/TerreDHermes/blob/main/assets/vk/удаление.png" alt="Описание изображения" style="width: 100%;">
</div>

Это последнее, что успел сделать (не до конца, но работает). Если interval_delete и period_delete равны нулю, то расписание удаления не меняется. Если у них есть значения, то вызывается функция UpdateDeleteSQL:

<div align="center">
  <img src="https://github.com/TerreDHermes/TerreDHermes/blob/main/assets/vk/измененеие%20расписания.png" alt="Описание изображения" style="width: 100%;">
</div>

Что не успел:

1) Добавить логику (если время жизни кортежа < текщуего временного окна, то обновлять, иначе нет);
   
2) Исправить ошибку -  interval_delete и period_delete перепутаны местами в запросах. Это не критично для работы, но не логично.


# Тестирование

Тесты написать не успел.

Есть реализация вызова функции Check в цикле, где учитываются введенные параметры. Располагается этот цикл в main. Он запускатеся сразу после сборки Makefile-а. 

<div align="center">
  <img src="https://github.com/TerreDHermes/TerreDHermes/blob/main/assets/vk/тесты.png" alt="Описание изображения" style="width: 100%;">
</div>

Чтобы нормально протестировать (с разными условиями), придется в цикле for менять время ожидания следующего запроса в time.Sleep(1 * time.Second), а также аргумент в floodControl.Check(ctx, 1), который отвечает за id пользователя.
 




# Что нужно сделать

Реализовать интерфейс с методом для проверки правил флуд-контроля. Если за последние N секунд вызовов метода Check будет больше K, значит, проверка на флуд-контроль не пройдена.

- Интерфейс FloodControl располагается в файле main.go.

- Флуд-контроль может быть запущен на нескольких экземплярах приложения одновременно, поэтому нужно предусмотреть общее хранилище данных. Допустимо использовать любое на ваше усмотрение. 

# Необязательно, но было бы круто

Хорошо, если добавите поддержку конфигурации итоговой реализации. Параметры — на ваше усмотрение.
